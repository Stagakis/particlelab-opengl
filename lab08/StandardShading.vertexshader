#version 330 core

// input vertex, UV coordinates and normal
layout(location = 0) in vec3 vertexPosition_modelspace;
layout(location = 1) in vec3 vertexNormal_modelspace;
layout(location = 2) in vec2 vertexUV;
layout (location = 3) in mat4 aInstanceMatrix;

out vec2 UV;
//out vec3 normal;

// Values that stay constant for the whole mesh.
uniform mat4 V;
uniform mat4 M;
uniform mat4 P;

mat4 lookAt(vec3 direction){
    vec3 rotation_vector = cross(vec3(0,1,0), normalize(direction));
    float theta = acos(dot(normalize(direction), vec3(0,1,0)));

    float u = rotation_vector.x;
    float v = rotation_vector.y;
    float w = rotation_vector.z;

    mat4 rotation_mat = mat4(1.0f);
    rotation_mat[0] = vec4(u*u + (1-u*u)*cos(theta), u*v*(1-cos(theta))+w*sin(theta), u*v*(1-cos(theta)) - v*sin(theta), 0);
    rotation_mat[1] = vec4(u*v*(1-cos(theta)) - w*sin(theta), v*v + (1-v*v)*cos(theta), v*w*(1-cos(theta)) + u*sin(theta), 0);
    rotation_mat[2] = vec4(u*w*(1-cos(theta)) + v*sin(theta), v*w*(1-cos(theta)) - u*sin(theta), w*w + (1-w*w)*cos(theta), 0);
    rotation_mat[3] = vec4(0,0,0,1);

    return rotation_mat;
}

void main() {
    // vertex position

    UV = vertexUV;

    mat4 test_rotate = lookAt(vec3(1,0,0));



    gl_Position =  P * V * aInstanceMatrix * test_rotate * vec4(vertexPosition_modelspace, 1);
    gl_PointSize = 10;
}
